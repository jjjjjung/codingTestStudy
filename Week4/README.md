
-----
# codingTestStudy - 4주차
-----

✍ <span style="color:red"> 완전탐색, 힙, dfs, bfs </span>

## 210726
- **2798번** - 블랙잭

> - 브루트 포스 첫 문제, 브루트 포스는 필요한 조건을 다 대입해보고 원하는 값을 찾아내는 것이라고 함
> - 삼중 반복문을 써야될거 같았는데 왜인지 모르게 익숙한 느낌으로 크게 어렵지 않게 해결,, 문해기 덕분인지 ^ . ^

- **2231번** - 분해합

*n*을 입력받고 1부터 *n*까지 반복문을 돌며 해당 수의 자리수를 리스트로 만들어준다

```py
num = list(map(int, str(i)))
```
그러고 해당 수와 자리수의 합을 더해서 *n*과 같으면 반복문을 종료하고 출력해준다.

처음에 *break*를 거는걸 까먹어서 틀렸는데 가장 작은 생성자를 구해야 하므로 원하는 답이 나오면 잊지말고 *break* 걸어줄 것

```py
if ans == n:
        res = i
        break
```

## 210727

- **1018번** - 체스판 다시 칠하기

> - 특정 크기의 보드를 만들어 주고 이 보드를 지민이가 8*8크기로 잘라서 검사를 한다
> - 보드를 자르는 것은 랜덤이므로 8*8사이즈로 자를 수 있는 모든 경우를 전부 검사해주도록 한다

보드 사이즈를 만들어주고 보드 각 행의 상태까지 입력해주는 코드는 어렵지 않게 작성

반복문을 만들어 주는데 처음부터 8칸씩 선택하므로 범위를 *n-7*과 *m-7*로 선택
    
```py
for i in range(n-7):
    for j in range(m-7):
```
그리고 선택한 8*8 크기의 보드를 처음부터 검사해줌
```py
for k in range(i, i+8):
    for l in range(j, j+8):
```

각 보드를 잘라서 (0, 0)를 기준으로 검사를 해주는데 한 칸씩 건너뛰며 같은지 다른지 확인 해줌

```py
if (k+l) % 2 == 0: #(0, 0)이 'W'일때
                    if board[k][l] != 'W':
                        ans1 += 1
                    if board[k][l] != 'B':
                        ans2 += 1 
```
같으면 *ans1*를 +1, 다르면 *ans2*를 +1해줘서 마지막에 더 작은 수를 *count* 배열에 넣어주고

```py
count.append(min(ans1, ans2))
```
모든 *for*문을 다 돌고 마지막에 또 *count*에서의 최소값을 출력해준다

```py
print(min(count))
```

```
사실 문제 풀다가 도~저히 모르겠어서 구글링을 좀 했다
정말 멋진 사람들이 많네 ... 
```

## 210728

***- dfs***: 깊이 우선 탐색, 모든 경우의 수 확인, 스택 자료구조나 재귀 함수 이용

***- bfs***: 너비 우선 탐색, 노드간 최단 거리를 계산, 큐 자료구조 이용

- **1260번** - DFS와 BFS

> - *Bfs*와 *Dfs*의 첫 문제, 이론만 보고 문제 시작했다가 다시 돌아가서 코드까지 공부하고 돌아옴

이 문제는 복잡하지 않아서 공부한 코드들로 바로 작성

코드를 작성하고 문제가 없다고 생각했는데 실행하니까 값이 무한대로 나옴

뭐가 잘못된지도 모르고 한참을 고민하다가 화가 나서 노트북을 치기 직전 오류를 발견했다... 물론 나의 실수였음

```py
이렇게 되어야 하는 코드를

check[i] = 1

이렇게 해주었으니 당연히 문제가 발생함

check[i] == 1
```

```
코드들을 능숙하게 사용하는건 아직 힘들지만 여러 문제들을 풀다보면 언젠가 익숙해질것
```

- **2606번** - 바이러스

> - 첫번째 문제에서 작성했던 코드를 이용해서 쉽게 해결
> - 노드가 연결될때마다 *cnt++* 해주면 됨

처음에 *cnt = 0*으로 해주고 노드가 연결될 때 마다 *cnt += 1* 해서 마지막에 *return cnt* 해주려고 했는데 실패

*cnt* 리스트를 만들어서 거기에 *append* 해주고 그 길이를 *return* 해주며 문제 해결!

```py
if graph[node][i] == 1 and check[i] == 0:
            cnt.append(i)
```

## 210728

- **2667번** - 단지번호붙이기

```py
for i in range():
    for j in range():
        num = int(input().strip())
        graph[i][j] = num
```
처음에 입력을 이렇게 받았었는데 생각해보니 잘못됨
입력을 하나씩 받는게 아니라 *0110100* 이렇게 받으므로

```py
graph.append(list(map(int, input().strip())))
```
이렇게 코드를 작성해 줌

집의 연결 여부를 파악할때 *dfs* 함수를 이용하는데 애초에 입력 받은 좌표가 지정된 정사각형의 범위를 넘어설때는 바로 *return* 해준다

```py
if x<0 or x>=n or y<0 or y>=n:
        return False
```
그리고 집이 있으면 동서남북 모든 방향으로 인접한 집이 없을 때 까지 재귀함수를 이용하여 검사를 해준다

사실 재귀함수랑 *return*값들을 생각하는데 애를 좀 먹었지만 이해하고나니 이해를 못했던게 이해가 안됐던,,ㅎㅎ

```py
for i in range(n):
    for j in range(n): # 이중 반복문을 돌면서 모든 집 검사
        if dfs(i, j) == True:
            res.append(cnt)
            cnt = 0
```
근데 마지막에 res.append(cnt)와 cnt=0 코드 순서를 바꿔써서 계속 0만 나오는 이상한 문제가 발생함,,, 겨우 해결

```
코드 작성하는게 점점 더 어려워지는 중인듯
코드도 길어지고 복잡해짐,,, 당연한가
이번 문제에서는 자잘한 실수들도 있었지만 dfs를 이용할때 재귀를 이용하는게 헷갈렸다 
그리고 넣어야 하는 코드들의 순서를 잘 생각해서 논리 오류가 발생하지 않도록 항상 신경써주기!!!
```

## 210729

- **1012번** - 유기농 배추

> - 이번 문제는 2667번과 유사해서 필요한 조건만 추가해주면 해결 가능
하지만 몇가지 신경써서 작성해줘야될 부분들이 있었음

이번 문제도 마찬가지로 이차원 배열을 사용하는데 이전 문제와는 달리 가로와 세로가 값이 다르므로 행렬 개념을 잊지말고 챙겨줘야함

```py
for _ in range(k):
    x, y = map(int, input().split())
    graph[y][x] = 1
```

그리고 위치를 입력받을 때 배추땅의 범위를 벗어나지 않을거라고 생각해서 밑의 코드를 작성하지 않았는데 오산이였음
```py
if x<0 or x>=n or y<0 or y>=m:
    return False
```
*dfs*를 재귀할때 오류가 발생한다고 떠서 고민해보니 상하좌우는 범위를 벗어날 수 있을 수 있다는 것을 간과했던것,,

그리고 마지막으로 재귀할때 깊이제한을 걸어줘야 런타임에러가 발생하지않는다
앞으로도 챙겨주기!

```py
sys.setrecursionlimit(10000)
```
- **2178번** - 미로 탐색
> - (0, 0)부터 (n, m)까지의 최단 거리를 구하는 문제이므로 *bfs*를 사용
> - *bfs*과 앞선 문제들의 상하좌우 검사하는 코드들을 이용하여 큰 문제없이 작성

*queue*에는 이동할 다음 좌표를 넣어줌,
그리고 *graph*에 여태까지의 최단거리에 *+1*한 값을 넣어줌으로써 마지막에 원하는 위치에 도달했을때 그 위치의 값을 읽어주는 방식으로 최단거리를 출력해주도록 함 

```py
if graph[na][nb] == 1:
    graph[na][nb] = graph[a][b] + 1
    queue.append((na, nb))
```

```py
print(graph[n-1][m-1])
```