
-----
# codingTestStudy - 4주차
-----

✍ <span style="color:red"> 완전탐색, 힙, dfs, bfs </span>

## 210726
- **2798번** - 블랙잭

> - 브루트 포스 첫 문제, 브루트 포스는 필요한 조건을 다 대입해보고 원하는 값을 찾아내는 것이라고 함
> - 삼중 반복문을 써야될거 같았는데 왜인지 모르게 익숙한 느낌으로 크게 어렵지 않게 해결,, 문해기 덕분인지 ^ . ^

- **2231번** - 분해합

*n*을 입력받고 1부터 *n*까지 반복문을 돌며 해당 수의 자리수를 리스트로 만들어준다

```py
num = list(map(int, str(i)))
```
그러고 해당 수와 자리수의 합을 더해서 *n*과 같으면 반복문을 종료하고 출력해준다.

처음에 *break*를 거는걸 까먹어서 틀렸는데 가장 작은 생성자를 구해야 하므로 원하는 답이 나오면 잊지말고 *break* 걸어줄 것

```py
if ans == n:
        res = i
        break
```

## 210727

- **1018번** - 체스판 다시 칠하기

> - 특정 크기의 보드를 만들어 주고 이 보드를 지민이가 8*8크기로 잘라서 검사를 한다
> - 보드를 자르는 것은 랜덤이므로 8*8사이즈로 자를 수 있는 모든 경우를 전부 검사해주도록 한다

보드 사이즈를 만들어주고 보드 각 행의 상태까지 입력해주는 코드는 어렵지 않게 작성

반복문을 만들어 주는데 처음부터 8칸씩 선택하므로 범위를 *n-7*과 *m-7*로 선택
    
```py
for i in range(n-7):
    for j in range(m-7):
```
그리고 선택한 8*8 크기의 보드를 처음부터 검사해줌
```py
for k in range(i, i+8):
    for l in range(j, j+8):
```

각 보드를 잘라서 (0, 0)를 기준으로 검사를 해주는데 한 칸씩 건너뛰며 같은지 다른지 확인 해줌

```py
if (k+l) % 2 == 0: #(0, 0)이 'W'일때
                    if board[k][l] != 'W':
                        ans1 += 1
                    if board[k][l] != 'B':
                        ans2 += 1 
```
같으면 *ans1*를 +1, 다르면 *ans2*를 +1해줘서 마지막에 더 작은 수를 *count* 배열에 넣어주고

```py
count.append(min(ans1, ans2))
```
모든 *for*문을 다 돌고 마지막에 또 *count*에서의 최소값을 출력해준다

```py
print(min(count))
```

```
사실 문제 풀다가 도~저히 모르겠어서 구글링을 좀 했다
정말 멋진 사람들이 많네 ... 
```

## 210728

***- dfs***: 깊이 우선 탐색, 모든 경우의 수 확인, 스택 자료구조나 재귀 함수 이용
***- bfs***: 너비 우선 탐색, 노드간 최단 거리를 계산, 큐 자료구조 이용

- **1260번** - DFS와 BFS

> - *Bfs*와 *Dfs*의 첫 문제, 이론만 보고 문제 시작했다가 다시 돌아가서 코드까지 공부하고 돌아옴

이 문제는 복잡하지 않아서 공부한 코드들로 바로 작성

코드를 작성하고 문제가 없다고 생각했는데 실행하니까 값이 무한대로 나옴

뭐가 잘못된지도 모르고 한참을 고민하다가 화가 나서 노트북을 치기 직전 오류를 발견했다... 물론 나의 실수였음

```py
이렇게 되어야 하는 코드를

check[i] = 1

이렇게 해주었으니 당연히 문제가 발생함

check[i] == 1
```
